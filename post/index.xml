<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>http://tbd.kaitoy.xyz/post/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2015</rights>
    <updated>2015-07-22 00:21:15 -0600 MDT</updated>

    
      
        <item>
          <title>Getter/Setterは悪だ。以上。</title>
          <link>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</link>
          <pubDate>Wed, 22 Jul 2015 00:21:15 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2003年にAllen Holubが書いた&lt;a href=&#34;http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html&#34;&gt;Why getter and setter methods are evil&lt;/a&gt;という有名な記事に端を発する古い議論がある。それは、getter/setterはアンチパターンで避けるべきものなのか、
もしくはオブジェクト指向プログラミングに必須なものなのかというもの。
この議論に少しだけ私の意見を加えたいと思う。&lt;/p&gt;

&lt;p&gt;上記記事の要旨はこうだ。
getterやsetterはひどい慣習で、これらを使うやつらはゆるせん。誤解の無いようもう一度言うが、
私はget/setを可能な限り避けるべきだと言っているのではない。それらは君のコードに決して現れてはいけないのだ。&lt;/p&gt;

&lt;p&gt;横柄で目につく物言いだろう?
君は15年来get/setパターンを使い続けている尊敬を集めるJavaアーキテクトなんだろう?
どこぞの馬の骨にこんなデタラメを言われたくはないだろう?
ああ、その気持ちはわかる。私がDavid Westの&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;という本に出会ったとき、
私もほとんど同じことを感じた。
Object Thinkingは、私が今まで読んだオブジェクト指向プログラミングについての本の中で最高のものだ。
だからお願いだ。ひとまず落ち着いて。私に説明させてほしい。&lt;/p&gt;

&lt;h3 id=&#34;既存の論拠:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;既存の論拠&lt;/h3&gt;

&lt;p&gt;オブジェクト指向の世界で、アクセッサ(getterやsetterの別名)に反対する論拠はいくつかあるが、
私にはそれら全てが十分に有力であるとは思えない。ひとつひとつ簡単に見ていこう。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;頼め、尋ねるな&lt;/p&gt;

&lt;p&gt;Allen Holub曰く、「ある処理をする際、その処理のために君が欲しい情報をオブジェクトに尋ねてはいけない。
その情報を持ったオブジェクトにその処理をするよう頼みなさい。」&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;カプセル化原則違反&lt;/p&gt;

&lt;p&gt;setterを通してどんな新たなデータも入力できるので、
一つのオブジェクトをその他の様々なオブジェクトが様々に扱うことができてしまう。
また、だれでもオブジェクトを変更できるので、
オブジェクトが単純に自身の状態を安全にカプセル化できない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;実装の詳細の暴露&lt;/p&gt;

&lt;p&gt;あるオブジェクトから他のオブジェクトを取得できる場合、前者のオブジェクトの実装の詳細に過度に依存してしまう。
もし明日その実装、例えば返すオブジェクトの型が変わったら、周辺のコードも書き換えないといけない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これらの全ての論拠は正当だが、重要なポイントが抜けている。&lt;/p&gt;

&lt;h3 id=&#34;根本的な誤解:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;根本的な誤解&lt;/h3&gt;

&lt;p&gt;ほとんどのプログラマはオブジェクトはメソッドを持ったデータ構造だと考えている。
ここでBozhidar Bozhanovによる記事、&lt;a href=&#34;https://dzone.com/articles/getters-and-setters-are-not&#34;&gt;Getters and Setters Are Not Evil&lt;/a&gt;から引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;しかし、人々がgetterやsetterをつけるオブジェクトのほとんどが、単純なデータホルダだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この思い違いが巨大な誤解の結果だ!
オブジェクトは単純なデータホルダではない。オブジェクトはメソッド付きのデータ構造ではない。
このデータホルダというコンセプトは、CやCOBOLといった手続き型言語からオブジェクト指向プログラミングに持ち込まれたものだ。
もう一度言う。オブジェクトはデータとそれを操作する関数をセットにしたものではない。
オブジェクトはデータエンティティではない。では何か?&lt;/p&gt;

&lt;h3 id=&#34;ボールと犬:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;ボールと犬&lt;/h3&gt;

&lt;p&gt;真のオブジェクト指向プログラミングでは、
オブジェクトは&lt;a href=&#34;http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html&#34;&gt;生きている生物&lt;/a&gt;だ。私や君と同じように。
オブジェクトは生きている有機体で、それ自身の挙動や、特性や、ライフサイクルを持っている。&lt;/p&gt;

&lt;p&gt;生きている有機体はsetterを持てるだろうか? 犬にボールを&amp;rdquo;set&amp;rdquo;できるだろうか? 無理だろう。
だが、以下のコードはまさにそれをしている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setBall(new Ball());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどう感じる?&lt;/p&gt;

&lt;p&gt;また、ボールを犬から取得できるだろうか?
まあ、できるかもしれない、もしその犬がボールを食べて、君が手術をするのであれば。
この場合、確かに、犬からボールを&amp;rdquo;get&amp;rdquo;できる。以下のコードが今話したようなことをやっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
Ball ball = dog.getBall();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またさらにばかげた例がこれだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setWeight(&amp;quot;23kg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現実世界でこの処理がどんなか想像できるかな?&lt;/p&gt;

&lt;p&gt;君が毎日書いているコードはこれに似ているかい?
もしそうなら、君は手続き型プログラマだ。認めなさい。
David Westが彼の本の30ページでそれについて以下のように言っている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;成功した手続き型開発者が成功するオブジェクト開発者に移行するための最初のステップは、ロボトミーだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;君はロボトミーが必要か？
因みに、WestのObject Thinkingを読んでいた時、私には明らかに必要だったので受けた。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト思考:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;オブジェクト思考&lt;/h3&gt;

&lt;p&gt;オブジェクト思考を開始すると、君は即座にメソッド名を変更し、多分以下のコードに辿り着く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.take(new Ball());
Ball ball = dog.give();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、私たちは犬を実際の動物として扱っている。この犬は、ボールを私たちから受け取り、頼めば返してくれる。
ここで特筆すべきは、この犬は &lt;code&gt;NULL&lt;/code&gt; を返すことはできない。犬は &lt;code&gt;NULL&lt;/code&gt; が何なのかなんて知らないからね。オブジェクト思考は即座に&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;NULL参照&lt;/a&gt;をコードから排除する。&lt;/p&gt;

&lt;p&gt;さらに、オブジェクト思考はオブジェクト不変性につながる。
犬の体重の例を、君は以下のように書き換えるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog(&amp;quot;23kg&amp;quot;);
int weight = dog.weight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この犬は不変な生きた有機体であり、だれも外からその体重やサイズや名前などを変更することはできない。
この犬は要求に応じて体重や名前を教えてくれる。
オブジェクトの中身を要求するパブリックメソッドには何の問題もないが、
こういったメソッドは&amp;rdquo;getter&amp;rdquo;ではなく、&amp;rdquo;get&amp;rdquo;というプレフィックスは決して付かない。
私たちは犬から何かを取ろうというのではない。犬から名前を取るのではなく、犬に名前を教えてくれるよう頼むのだ。
この違いが分かるかな?&lt;/p&gt;

&lt;p&gt;語義論の話をしているというわけでもない。
手続き型プログラミング思考とオブジェクト指向プログラミング思考とを区別しようというのだ。
手続き型プログラミングでは、私たちはデータを扱い、必要に応じてそれを操作したり取得したりセットしたり消したりする。
私たちはデータの責任者で、そのデータは単なる受動的なコンポーネントだ。
犬は私たちとは何の関係もなく、ただのデータホルダだ。それは生命を持っていない。
私たちはそれから必要なものを何でも自由に取得できるし、どんなデータでもセットすることができる。
これがCやCOBOLやPascalなどの手続き型言語のやりかただ。&lt;/p&gt;

&lt;p&gt;それに対して、真のオブジェクト指向の世界では、オブジェクトを生きた有機体のように扱い、
オブジェクトには生まれた日と死ぬ瞬間がある。また、君が望むなら、アイデンティティや性質を持たせてもいい。
犬にはデータの一部(例えば体重)をくれるよう頼むことができるし、犬はその情報を返してもよい。
ただ、この犬は能動的なコンポーネントであることを忘れてはいけない。
こちらの要求に対し、何をするかは犬が決めるのだ。&lt;/p&gt;

&lt;p&gt;以上が、getやsetで始まるメソッドをオブジェクトに持たせることが概念的に間違っている理由だ。
それは、多くの人々が主張するように、カプセル化を崩すということではない。
それは、君がオブジェクト的な思考をしているか、もしくは今だCOBOLをJavaのシンタックスで書いているかということだ。&lt;/p&gt;

&lt;p&gt;追伸: そうだ、君はこう尋ねるかもしれない。JavaBeans、JPA、JAXBなどのget/set表記に頼るJava APIはどうなんだ?
Rubyに付属するアクセッサ生成を簡易化する機能は?
ああ、それらは全て私たちにとっての不幸だ。
手続き型COBOLの原始的な世界に留まることは、真のオブジェクトからなる美しい世界を正しく理解し感謝するのに比べてはるかに簡単だ。&lt;/p&gt;

&lt;p&gt;追追伸: 言い忘れたが、setterを使った依存性注入もひどいアンチパターンだ。
それについてはいずれ書く。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Javaを始めた当初から今まで、Getter/Setterは絶対正義だと信じ、クラスを作れば無心でIDEの言いなりにそれを生成していたので、
この記事はなかなかに刺激的だった。(まあfinalなフィールドが好きなのでsetterの方はあまり作らなかったが。)&lt;/p&gt;

&lt;p&gt;ただ、記事の本質としては、Getter/Setterパターン、つまり、
オブジェクトのフィールドをprivateにし、メソッドを介してアクセスさせるようにすることで、実装の詳細を隠蔽し、
APIと分離させることを図るデザインパターンの技術的役割や目的を否定しているわけではなく、
オブジェクト指向の哲学的な部分にも則り、Getter/Setterパターンを真のオブジェクト界に向けて昇華させましょうと言っているように読める。&lt;/p&gt;

&lt;p&gt;犬とボールのやり取りをするコードのビフォーアフターはsetBall/getBallがtake/giveになっただけで、
これだけ見れば処理が変わるわけでもないし、コンパイラに言わせればどっちでもいいだろとなる。
ただ、プログラマにボールを無下につっこまれるビフォーの犬よりも、
自ら能動的にボールを受け取り返してくれるアフターの犬の方が幸せそうで愛らしいのは確かだ。
真のオブジェクト界を垣間見た気がする。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Pcap4J container with runC</title>
          <link>http://tbd.kaitoy.xyz/2015/07/19/pcap4j-container-with-runc/</link>
          <pubDate>Sun, 19 Jul 2015 16:25:03 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/19/pcap4j-container-with-runc/</guid>
          <description>

&lt;p&gt;I tried to run a &lt;a href=&#34;https://registry.hub.docker.com/u/kaitoy/pcap4j/&#34;&gt;Pcap4J container&lt;/a&gt; with &lt;a href=&#34;https://runc.io/&#34;&gt;runC&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-is-pcap4j:d8cdddcb3c661497917906608717271a&#34;&gt;What is Pcap4J?&lt;/h2&gt;

&lt;p&gt;Pcap4J is a Java library for capturing, crafting, and sending packets.
It&amp;rsquo;s actually a Java wrapper for libpcap/WinPcap plus packet analyzer.
We can see the details in its &lt;a href=&#34;https://github.com/kaitoy/pcap4j&#34;&gt;README&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-is-runc:d8cdddcb3c661497917906608717271a&#34;&gt;What is runC?&lt;/h2&gt;

&lt;p&gt;runC is a container runtime developed by Docker and released on June 22, 2015.
With runC, we can start a container from a docker image without the docker service or the docker command.&lt;/p&gt;

&lt;p&gt;That said, as of now, runC cannot directory use docker images.
We need to create a container form a docker image and export its filesystem before executing runC.&lt;/p&gt;

&lt;p&gt;It seems currently it supports only Linux but Windows support is in the roadmap.&lt;/p&gt;

&lt;h2 id=&#34;what-i-did:d8cdddcb3c661497917906608717271a&#34;&gt;What I did&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;OS: CentOS 7 (on VMware Player 7.1.0 on Windows 7)&lt;/li&gt;
&lt;li&gt;user: root&lt;/li&gt;
&lt;li&gt;runC version: 0.2&lt;/li&gt;
&lt;li&gt;Pcap4J version: 1.5.1-SNAPSHOT&lt;/li&gt;
&lt;li&gt;Docker version: 1.6.2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prerequisites:

&lt;ul&gt;
&lt;li&gt;Docker is installed and Docker service is started&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; is installed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Step by step&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install runC&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# mkdir -p $GOPATH/src/github.com/opencontainers
[root@localhost ~]# cd $GOPATH/src/github.com/opencontainers
[root@localhost opencontainers]# git clone https://github.com/opencontainers/runc
[root@localhost opencontainers]# cd runc
[root@localhost runc]# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pull the Pcap4J docker image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# docker pull kaitoy/pcap4j
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a container from the image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# docker run -d --name pcap4j-tmp kaitoy/pcap4j:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Export the container&amp;rsquo;s file system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# mkdir /tmp/pcap4j-test
[root@localhost pcap4j-test]# cd /tmp/pcap4j-test
[root@localhost pcap4j-test]# docker export pcap4j-tmp &amp;gt; pcap4j.tar
[root@localhost pcap4j-test]# tar xf pcap4j.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are now free from Docker. We don&amp;rsquo;t need Docker service, Docker command, Docker images, nor Docker containers anymore.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a container config file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost pcap4j-test]# runc spec | sed -e &#39;s/rootfs/\/root\/Desktop\/pcap4j-container/&#39; -e &#39;s/&amp;quot;readonly&amp;quot;: true/&amp;quot;readonly&amp;quot;: false/&#39; -e &#39;s/&amp;quot;NET_BIND_SERVICE&amp;quot;/&amp;quot;NET_BIND_SERVICE&amp;quot;,&amp;quot;NET_ADMIN&amp;quot;,&amp;quot;NET_RAW&amp;quot;/&#39; &amp;gt; config.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above command, &lt;code&gt;runc spec&lt;/code&gt; generates a standard container config file and &lt;code&gt;sed&lt;/code&gt; modifies it for Pcap4J.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run a container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost pcap4j-test]# runc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the container, enable lo.&lt;/p&gt;

&lt;p&gt;As far as I saw, lo is the only interface we can use in a container.
So, I used it to capture packets.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sh-4.1# ifconfig lo up
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a script to ping localhost and run it background.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sh-4.1# cd /usr/local/src/pcap4j/bin
sh-4.1# echo ping 127.0.0.1 \&amp;gt; /dev/null &amp;gt; pinger.sh
sh-4.1# chmod +x pinger.sh
sh-4.1# ./pinger.sh &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next step, ICMP packets from this pinger.sh will be captured.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a script to start capturing packets with Pcap4J and run it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sh-4.1# cat runGetNextPacket.sh | sed -e &#39;s/eth0/lo/&#39; &amp;gt; foo.sh
sh-4.1# chmod +x foo.sh
sh-4.1# ./foo.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see the ICMP packets are dumped on the terminal. That&amp;rsquo;s it!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>First Post</title>
          <link>http://tbd.kaitoy.xyz/2015/07/18/first-post/</link>
          <pubDate>Sat, 18 Jul 2015 13:10:37 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/18/first-post/</guid>
          <description>&lt;p&gt;初投稿。&lt;/p&gt;

&lt;p&gt;ブログを立ち上げようと思ったきっかけは、&lt;a href=&#34;https://www.google.co.jp/search?q=teamed.io&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;hl=ja&#34;&gt;Teamed.io&lt;/a&gt;というCaliforniaのソフトウェアアウトソーシング(?)をやってる会社のCTO、
Yegor Bugayenko (yegor256)のブログのエントリ、&lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html&#34;&gt;How Much Do You Cost?&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これは、Teamed.ioがエンジニアに払うfeeを決める際の指標についてのエントリで、その指標の一つとして &lt;em&gt;Talks and Publications&lt;/em&gt; を挙げている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Both blog articles and conference presentations make you much more valuable as a specialist.
Mostly because these things demonstrate that some people already reviewed your work and your talent.
And it was not just a single employer, but a group of other programmers and engineers.
This means that we also can rely on your opinions.&lt;/p&gt;

&lt;div style=&#34;font-size: 0.5em; text-align: right;&#34;&gt;&lt;cite&gt;引用元: &lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&#34;&gt;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&lt;/a&gt;&lt;/cite&gt;&lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;つまり、カンファレンスで発表したりブログで意見を発信すると、それらを見た様々な人たちによってレビューされフィードバックを受けることになるので、
そういった経験が多いエンジニアは、より洗練された考えや技術を持っているとみなせるということ。&lt;/p&gt;

&lt;p&gt;確かに、普段会社の同僚としか接しないので、自分の意見を広く発信してフィードバックを受けるのは刺激になりおもしろそうだしためになりそう。
ただそのためにはこのブログが広く読まれコメントをもらえるまでになる必要があるが、それはさておき、
文筆の練習として、また物事に対する理解を深めるためにも、書くということは有益であろう。備忘録にもなるし。&lt;/p&gt;

&lt;p&gt;因みに、Yegorはオブジェクト指向プログラミングの原理主義者で、ソフトウェア開発に対して非常に厳格で斬新な(異端な?)考え方を持っている。
それは例えば彼の以下のブログエントリに見られる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt; (スタンドアップミーティングはダメマネージャーが好む手法)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html&#34;&gt;ORM Is an Offensive Anti-Pattern&lt;/a&gt; (ORMはけしからんアンチパターン)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt; (GetterやSetterは悪だ。以上。)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下で働くと苦労しそうなタイプな気はするが、言っていることは面白いし説得力もあるので、いくつかのエントリを和訳しておいおいここで紹介していこうかと思う。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
