<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>http://tbd.kaitoy.xyz/tags/yegor256/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2015</rights>
    <updated>2015-08-11 22:35:09 -0600 MDT</updated>

    
      
        <item>
          <title>スタンドアップミーティングはダメマネージャーが好む手法</title>
          <link>http://tbd.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</link>
          <pubDate>Tue, 11 Aug 2015 22:35:09 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;スタンドアップミーティング (または単純にスタンドアップ)は、「チームマネージャに状況報告をするためのデイリーチームミーティング」であるとWikipediaに書かれている。
こうしたミーティングは、ソフトウェア開発チームの間でとても人気な手法ではあるが、単なる悪であり、よいマネージャは決してやらない。
以下、その理由を説明する。&lt;/p&gt;

&lt;p&gt;私は、スタンドアップのやり方が適切だったり不適切だったりする、と言いたいわけではない。それについて述べた記事は大量にある。
また、スタンドアップを上手く機能するように実施する方法についてアドバイスしようとしているわけでもない。
よいマネージャはデイリースタンドアップを決して実施すべきでないと言っているのだ。
スタンドアップは、単に「機能しない」だけでなく、非常に悪い、時に破壊的なものをマネジメントプロセスにもたらす。それがアジャイルかどうかにかかわらず。
一方、ダメなマネージャは常に、デイリースタンドアップを重要なマネジメント手法として使う。&lt;/p&gt;

&lt;p&gt;私の意図を説明するため、マネジメントをいくつかの異なった視点から見ながら、よいマネージャとダメなマネージャが仕事をどのように進めるかを比べてみよう。&lt;/p&gt;

&lt;h3 id=&#34;情報:8275609fe70e62212bad6f05bff26921&#34;&gt;情報&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは進捗を尋ねる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;オフィスを歩き回り進捗を訪ねて回るのは、ひどいマネージャの崇高な習慣だ。
彼は、プロセスと情報伝達フローを適切に構築できるほど賢明ではなく、チームが何をしているかを知らない。
しかし、彼は進捗を知る必要がある。彼もまた上司からちょくちょく尋ねられるからだ。
必要な情報を収集する唯一の方法は、チームに「今何の作業をしているの?」と尋ねることだ。
朝のスタンドアップは、メンバの作業内容を知らないことに気付かれずに、このうっとうしい質問を正式に尋ねる最高の場だ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは必要なときに報告を受ける。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;プロジェクトマネージメントにはコミュニケーション管理が必要だ。
情報伝達フローが適切に構成されていれば、チームメンバはいつどのようにマネージャに報告すればいいかが分かる。
何か問題が起きたとき、そういう状況をどのように報告しなければいけないかを全員が知っている。即時、直接報告するのだ。
作業が完了したとき、必要に応じてプロジェクトマネージャにどのように知らせるかを全員が理解している。
完璧なプロジェクトマネージャは決してチームに質問しない。代わりに、チームが必要なときにマネージャに報告する。
そして、報告を怠るメンバが出たときには、その壊れたコミュニケーションチャネルを修復するのがよいプロジェクトマネージャだ。
ただし、情報収集のためにデイリーミーティングは決して実施しない。&lt;/p&gt;

&lt;p&gt;よいマネージャとして、何がゴールで何がプロジェクトマネージャ(またはスクラムマスタ)として重要かをチームに伝えるべきだ。
チームメンバは、マネージャがチームの進捗、リスク、障害、失敗について知るために何が重要であるかを知っているべきだし、チームメンバがマネージャの期待に沿えなければどんなトラブルに陥るかを理解しているべきだ。
プロジェクトやチームが取り組んでいる最も重要な課題についてをチームに伝えることは、よいマネージャとしてすべき仕事だ。
また、よいチームメンバとしては、重要な情報をつかんだら、すぐにマネージャに知らせることが重要だ。
これが完璧なマネージメントというものだ。&lt;/p&gt;

&lt;p&gt;もしそのようなチームワークを築いたなら、開発者が今日何をしてどんな問題にあったかを、明日の朝まで待ってから尋ねる必要はなくなる。
マネージャはこういった情報をもっと早く、まさに必要なタイミングで知るようになる。
オフィスの外にいるときでさえ、プロジェクトで起こっていることを知ることができるようになる。
実際には、オフィスは全く不要にさえなるが、これはまた別の機会に議論したい。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップはプログラマ間で情報交換する最高の機会で、スクラムマスタに報告してフィードバックを受けるだけの場ではないと言う人がいるかもしれない。
もう一度、同じことを言うが、なぜ、その日の必要になった時点で情報交換をしないのか?
なぜ、10人のメンバを毎朝集めて、その内たった5人だけに関係することを議論する必要がある?
答えよう。ダメなマネージャは、チームメンバ間で情報交換する場を用意する他の方法を知らず、朝のスタンドアップを適切なコミュニケーションモデルの代わりとして使う。
こういったミーティングは、マネージャが熱心に働いていて、大げさな給料を受け取るに値するかのような印象を与える。
対照的に、よいマネージャは定期的な状況報告ミーティングをいっさい実施しない。
なぜなら、効果的なコミュニケーションツールの使い方を知っているからだ。
例えば、問題追跡ツール、メール、コードレビュー、意思決定ミーティング、ペアプログラミングなど。&lt;/p&gt;

&lt;h3 id=&#34;責任:8275609fe70e62212bad6f05bff26921&#34;&gt;責任&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャはマイクロマネージメントをする。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはプロジェクトマネージメントのことをほとんど知らないので、大きな不安を抱えている。
彼はチームのコントロールを失うことを恐れていて、チームを信頼せず、いつも十分な情報を得ていないと感じ、上司から状況を尋ねられたときに動揺する。
このため、彼はチームメンバを抗うつ薬として使う。チームメンバが彼の言う通りのことをしているとき、彼はより安心と安定を感じる。
デイリースタンドアップミーティングは、彼がメンバに何をしているかを尋ね、代わりに何をすべきかを指示するためのすばらしい機会だ。
このマネージャは、メンバに個人の目標と計画を報告するよう強制し、必要だと感じればそれらを修正する。
次のようなやりとりをを何回聞いたことがある?「私はテストXをやるつもりです。…いや、それは来週だ。今日はYをやってくれ。」
これはマイクロマネージメントだ。デイリースタンドアップはマイクロマネージャのための完璧なツールだ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは責任を委譲する。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントには4つのステップが必要だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;複雑なタスクを小さいサブタスクに分解する。&lt;/li&gt;
&lt;li&gt;それらを部下に委譲する。&lt;/li&gt;
&lt;li&gt;報酬と、ペナルティと、ルールをはっきりと伝える。&lt;/li&gt;
&lt;li&gt;報酬はちゃんと支払われること、ペナルティは免れられないこと、ルールは厳格に守られることを確実にする。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完璧なマネージャは日々何をするかをメンバに指示しないし、業務時間の使い方にも口を出さない。
彼は信頼し、コントロールする。
彼は、メンバに作業方法を指示して自尊心を削ぐようなことは決してしない。
すばらしいマネージャは次のようなことを言う。「今日はテストXをやるつもりだって? それは君の判断だ。最大限尊重するよ。ただ、Yが今週中に完了しなければ、君は約束どおりプロジェクトからはずされるということを忘れないでくれ。」
こういうマネージャにデイリースタンドアップが必要だろうか?
チームメンバに何をしているか聞く必要があるだろうか?
彼はメンバの計画によけいな干渉はしない。
代わりに、メンバを信頼し、成果をコントロールするだけだ。&lt;/p&gt;

&lt;p&gt;重ねて言うが、私は責任は委譲されるべきだと強く信じている。この委譲は3つの要素からなる。報酬、ペナルティ、ルールだ。
近代西洋文化の中では、これらを定めるのはむしろ難しいかもしれない。普通は長期の契約と月々の給料がある。
しかし、よいマネージャは方法を模索しないといけない。それぞれのタスクは委譲され、分離されないといけない。
これは、あるタスクに従事しているプログラマは、その成功または失敗に個人的な責任を持たなければいけないということだ。
また、そのタスクの結果が与える影響を知っていなければいけない。&lt;/p&gt;

&lt;p&gt;よいマネージャは、どんなチームメンバでも必ず責任逃れをしようとするということを理解している。
誰もがマネージャの両肩に&lt;a href=&#34;http://hbr.org/1999/11/management-time-whos-got-the-monkey/ar/1&#34;&gt;責任猿&lt;/a&gt;(訳注: 責任のメタファである猿)を返そうとする。
それは自然で不可避なことだ。デイリースタンドアップミーティングはこのたくらみを助長するだけだ。&lt;/p&gt;

&lt;p&gt;朝、君が私に進捗を聞くと、私はいくつか問題があって今週末までにタスクが完了できるか怪しいと言う。
それだけだ。私はもうそのタスクに責任がない。もし間に合わなくても私の失敗ではない。
私は失敗するかもしれないと伝えたよね?
今後、その責任は君がもつんだ。&lt;/p&gt;

&lt;p&gt;よいマネージャはこういう策略について知っていて、それを防ぐために報酬・ペナルティ・ルールを明確に規定する。
もし間に合わないかもしれないと言われたら、報酬を逃しペナルティを受けることを思い出させればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;- 締め切りに間に合わないかもしれない…
- それは残念だ。君は$200の週末ボーナスを逃すことになる。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクトマネージャやスクラムマスタがこんなことを言っているのを見たことがあるかい?
あまりないと思う。そう、よいマネージャは珍獣なんだ。
しかし、よいマネージャだけが報酬・ペナルティ・ルールを明確に厳格に定義する能力を持つ。&lt;/p&gt;

&lt;p&gt;この3点が定義されれば、毎朝状況報告ミーティングをする必要はなくなる。
全てがありのままに明確になる。全員がゴールと目標を把握する。
全員が失敗したときに何が起こるかを知っているし、成功したときに何を得られるかも知っている。
マネージャは毎朝それをメンバに確認する必要はない。マネージャはメンバの進捗を確認する必要もない。
マネージャは既に非常に明確に各メンバの目標を定めている。それについて毎朝話す必要があるだろうか?&lt;/p&gt;

&lt;p&gt;ダメなマネージャは目標を定める能力がないので、毎朝メンバをマイクロマネージメントしようとする。
実際、ダメなマネージャは一日中マイクロマネージメントしている。
明確なゴールやルールがないので、チームが間違ったことをしたり何もできなかったりするのではないかと恐れている。
しょっちゅう状況確認するのはそのせいだ。
実際のところ、彼はチームの首根っこをつかんでいるのだ。&lt;/p&gt;

&lt;h3 id=&#34;モチベーション:8275609fe70e62212bad6f05bff26921&#34;&gt;モチベーション&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは皆の前で恥をさらさせてモチベーションを下げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはチームメンバにやる気を出させる適切な仕組みの作り方を知らないため、恥をさらすことへの生理的な恐怖を利用する。
誰も「忘れました」と皆の前で言いたくないのが当然だ。
デイリースタンドアップミーティングは全員を一列に並べて「昨日何をした?」と尋ねる場だ。
この恐怖の時間はチームにやる気を出させるだろ?
私はそうは思わないが。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは目標でモチベーションを上げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントは、目標を定めて、チームメンバがスキル、リソース、知識、情熱を駆使してそれを達成できるようにする。
適切に定められた目標は常に3つの要素からなる。報酬、ペナルティ、ルールだ。
すばらしいマネージャは組織の目標を個人の目標に落とし込む方法を知っている。
「もし今週中にこの機能を納品できたら、会社はさらなる利益を出せる。サリー、君個人としては$500を得る。もし君がしくじったら、君は他の、あまり面白くないプロジェクトに異動することになる。」
これが完璧に定められた目標だ。毎朝、皆の前で、機能の実装を忘れてないかとか、熱心に作業しているかとか、サリーに尋ねる必要があるだろうか?
この尋問は彼女の手助けになるだろうか?
なるはずがない !
彼女は既に何のために作業しているか知っていて、動機付けは十分だ。
彼女が期日に作業を終えたら、ミーティングを開いて、皆の前で$500のチェックをあげよう。
これがよいマネージャによるミーティングの使い方だ。&lt;/p&gt;

&lt;p&gt;他にもある。
皆の前での日々の進捗報告は、チーム内最高のメンバを堕落させ、最悪にしてしまう。
主な理由は、彼らは突出した成果を出すことで他の人の気を損ねたくないからだ。
グループ内で他の皆と同じように振舞おうとするのは、人間の性だ。
皆が「まだ結果は出ていません」と報告しているときに、有能なプログラマが「全てのタスクを終えたので、他の仕事をください」と言うことを期待するのは奇妙だ。
いや、一回くらいはこういうことを言うかもしれないが、しばらくするとこの有能なプログラマは熱心に作業することをやめるか、チームを抜ける。
彼は、彼の成果が際立っていることを知り、それがグループから評価されていないことを知る。マネージャが何を言おうとも。&lt;/p&gt;

&lt;p&gt;よいマネージャは、プログラマそれぞれに固有の作業速度、質、給料があることを理解する。
よいマネージャは、人によって与えるタスクを変え、異なる結果が返ってくることを期待する。
明らかに、朝全員を並ばせて、皆が同じような報告をすることを期待するのは大きな間違いだ。
この間違いは、突出した成果を出して格別な評価と報酬を得たがっている有能なメンバに破壊的な効果をもたらす。&lt;/p&gt;

&lt;p&gt;ダメなマネージャは異なる人々を異なる方法でマネージメントできない。単にやり方を知らないからだ。
そのため、デイリースタンドアップという、全員が同じような、比較しやすい成果を報告する場が必要になる。
また、皆と違った報告をする人を責めたり励ましたりもしやすい。
言い換えると、ダメなマネージャはデイリースタンドアップを平等の手段として使う。この場合の平等は、チーム全体のモチベーションを破滅させるだけだ。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップや、他のあらゆる状況報告ミーティングは、怠惰で愚かなマネージャを隠して守るのにはすばらしい手段だ。
マネージャの無能っぷりをチームメンバから隠すことができる。
適正のなさを隠し、問題や挑戦やリスクへの恐れを隠す。
よいマネージャになりたいなら、デイリースタンドアップで自分自身を困らせないことだ。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Yegorは、自身が経営する&lt;a href=&#34;http://www.teamed.io/&#34;&gt;Teamed.io&lt;/a&gt;という会社でのソフトウェア開発プロジェクトを、自身が考案した&lt;a href=&#34;http://www.xdsd.org/&#34;&gt;XDSD&lt;/a&gt;という手法を使ってマネジメントしている。
上の記事は、そのXDSDを念頭に、
巷で流行っている&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0_%28%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%29&#34;&gt;スクラム&lt;/a&gt;などで行われるデイリースタンドアップにはっきりと異を唱えるものだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.agilemanifesto.org/iso/ja/&#34;&gt;アジャイルソフトウェア開発宣言&lt;/a&gt;が発表されてから14年もたち、私の会社のような古い体質の組織にもアジャイルな手法や理念はさすがに浸透していて、私の周りでもデイリーミーティングをするチームが目立つ。私としては、管理される側にとっても、管理する側にとっても、いい情報交換の場だとは思うが、だらだら長くなりがちで、じわじわ煩わしくなるのが難。&lt;/p&gt;

&lt;p&gt;Yegorは、定例ミーティングなんかやめて、情報交換は必要なときに必要な人どうしでやれよと言っているわけだけど、悪いニュースは隠したくなるし、いいニュースもきっかけがないと報告するのがおっくうになるのは自然の摂理ではないか。
この摂理を乗り越え、適時情報共有するための、「適切な情報伝達フロー」の作り方は、また別の記事に書かれているんだろうか。&lt;/p&gt;

&lt;p&gt;責任の委譲についてのくだりは、以前読んだドラッカーを思い出した。もしドラだけど。
ドラッカーは「権限 (authority) を委譲しろ」と言っていたけど、Yegorは「責任 (responsibility) を委譲すべき」と言っている。
また、ドラッカーは、「権限の委譲を責任の放棄と混同してはいけない。権限を委譲したらむしろマネージャの責任は大きくなる」と言っていた。
つまり、Yegorはここでさらっとドラッカーにも異を唱えていることになる。
権威によるバイアスもあるのかもしれないが、私にはやはりドラッカーの話の方がしっくりくる。責任は猿みたいに身軽に移動できるものとは思えない。
失敗した部下のボーナスを減らして別のプロジェクトに飛ばしたところで、開発の遅れを取り戻せるわけではないし、納品が遅れたら怒られるのは結局上の人たちだ。&lt;/p&gt;

&lt;p&gt;ところで、XDSDもそうっぽいけど、アジャイルな開発手法は基本的に、意欲に満ちた優秀なメンバで構成されたチームを前提に組み立てられたものだ。
私の会社を含む、日本の大企業がやっているような、経験(ほぼ)不問、サークルやバイトでの体験談を聞いて新卒一括人柄採用なんてボランティアみたいな選考方法を刷新しない限り、上手く回るようになることはない。
こんないい加減なやり方で集められた烏合の衆で、何千万も何億も稼ぐソフトウェアを作ろうってんだから、上の人たちはさぞかし大変なんだろう。意欲に欠けた部下の尻を叩くためにデイリースタンドアップをやらざるを得ないマネージャを批判するのは、ちょっと気の毒に思える。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>なぜNullはダメか</title>
          <link>http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/</link>
          <pubDate>Sun, 26 Jul 2015 19:07:20 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;Why NULL is Bad?&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Javaで&lt;code&gt;NULL&lt;/code&gt;を使う単純な例を以下に示す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return null;
  }
  return new Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このメソッドの何が間違っているのか? オブジェクトの代わりに&lt;code&gt;NULL&lt;/code&gt;を返す可能性がある、というのが間違っているところだ。
&lt;code&gt;NULL&lt;/code&gt;はオブジェクト指向パラダイムにおけるひどい慣習で、全力で避けるべきものだ。
これについては多くの意見が既に発表されている。
たとえば、Tony Hoareによるプレゼン&lt;a href=&#34;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;Null References, The Billion Dollar Mistake&lt;/a&gt;や、David Westの著書&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;の全体に渡って述べられている。&lt;/p&gt;

&lt;p&gt;ここで、その論拠のすべてをまとめ、&lt;code&gt;NULL&lt;/code&gt;の使用を回避して適切なオブジェクト指向構造に置き換える方法の例を紹介したいと思う。&lt;/p&gt;

&lt;p&gt;基本的に、&lt;code&gt;NULL&lt;/code&gt;の代わりになり得るものはふたつある。&lt;/p&gt;

&lt;p&gt;ひとつは&lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;Nullオブジェクト&lt;/a&gt;デザインパターンだ。(それをひとつの不変オブジェクトにするのが最善。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return Employee.NOBODY;
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もうひとつは、オブジェクトを返せないときに例外を投げて&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;することだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    throw new EmployeeNotFoundException(name);
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、&lt;code&gt;NULL&lt;/code&gt;に反対する論拠を見てみよう。&lt;/p&gt;

&lt;p&gt;因みに、上記Tony HoareのプレゼンやDavid Westの著書に加えて、私はこの記事を書く前に以下の本や記事を読んだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Robert Martinの&lt;a href=&#34;http://www.amazon.com/dp/0132350882/&#34;&gt;Clean Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Steve McConnellの&lt;a href=&#34;http://www.amazon.com/dp/0735619670/&#34;&gt;Code Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;John Sonmezの&lt;a href=&#34;http://elegantcode.com/2010/05/01/say-no-to-null/&#34;&gt;Say &amp;ldquo;No&amp;rdquo; to &amp;ldquo;Null&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StackOverflowの&lt;a href=&#34;http://stackoverflow.com/questions/1274792/is-returning-null-bad-design&#34;&gt;Is returning null bad design?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;アドホック-場当たりな-エラー処理:08adb1e15fed47fdc6706e8240d4bde7&#34;&gt;アドホック(場当たりな)エラー処理&lt;/h3&gt;

&lt;p&gt;インプットとしてオブジェクトを受け取った場合は常に、それが&lt;code&gt;NULL&lt;/code&gt;でないか、また有効なオブジェクト参照かどうかを確認しないといけない。
その確認を忘れると、&lt;code&gt;NullPointerException&lt;/code&gt; (NPE)が実行時に処理を止めてしまう恐れがある。
このため、ロジックが複数の確認処理やif/then/else分岐に汚染されてしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// this is a terrible design, don&#39;t reuse
Employee employee = dept.getByName(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  System.out.println(&amp;quot;can&#39;t find an employee&amp;quot;);
  System.exit(-1);
} else {
  employee.transferTo(dept2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/C%E8%A8%80%E8%AA%9E&#34;&gt;C&lt;/a&gt;などの命令文を並べる手続き型言語において、例外的な状況に対応する手法だ。
OOPは、主にこういったアドホックエラー処理のブロックを排除する目的で、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86&#34;&gt;例外処理&lt;/a&gt;を導入した。
OOPでは、例外処理をアプリケーションレベルのエラーハンドラにまかせることで、コードをかなりきれいで短いものにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dept.getByName(&amp;quot;Jeffrey&amp;quot;).transferTo(dept2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;参照は手続き型言語から受け継がれたものだと認識し、Nullオブジェクトか例外を変わりに使うべきだ。&lt;/p&gt;

&lt;h3 id=&#34;あいまいな意図:08adb1e15fed47fdc6706e8240d4bde7&#34;&gt;あいまいな意図&lt;/h3&gt;

&lt;p&gt;上記メソッドの目的を明確に伝えるためには、&lt;code&gt;getByName()&lt;/code&gt;は&lt;code&gt;getByNameOrNullIfNotFound()&lt;/code&gt;という名前でなければいけない。
これと同様の名前を、オブジェクトか&lt;code&gt;NULL&lt;/code&gt;を返す全ての関数が持たなければいけない。
さもなくば、だれかがあいまいなコードを読むはめになる。だから、コードの意図を明確にするために、関数に長い名前をつけるべきだ。&lt;/p&gt;

&lt;p&gt;このあいまいさを排除するために、関数は、実オブジェクトを返すか、Nullオブジェクトを返すか、例外を投げる、しかしてはいけない。&lt;/p&gt;

&lt;p&gt;性能を考慮すると&lt;code&gt;NULL&lt;/code&gt;を返さざるを得ない場合もあるだろうと主張する人がいるかもしれない。
たとえば、Javaの&lt;code&gt;&lt;a href=&#34;http://docs.oracle.com/javase/jp/7/api/java/util/Map.html&#34;&gt;Map&lt;/a&gt;&lt;/code&gt;インターフェースの&lt;code&gt;get()&lt;/code&gt;メソッドは、指定された要素がないときに&lt;code&gt;NULL&lt;/code&gt;を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Employee employee = employees.get(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  throw new EmployeeNotFoundException();
}
return employee;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは、&lt;code&gt;Map&lt;/code&gt;が&lt;code&gt;NULL&lt;/code&gt;を使っているおかげで、mapを一回しか検索しない。
もし、&lt;code&gt;Map&lt;/code&gt;の&lt;code&gt;get()&lt;/code&gt;を、要素が見つからないときに例外を投げるように修正したら、以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (!employees.containsKey(&amp;quot;Jeffrey&amp;quot;)) { // first search
  throw new EmployeeNotFoundException();
}
return employees.get(&amp;quot;Jeffrey&amp;quot;); // second search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明らかに、この方法は最初のものより2倍遅い。さて、どうする?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;インターフェースは、(作者を攻めるわけではないが、)設計に問題がある。
その&lt;code&gt;get()&lt;/code&gt;メソッドは&lt;code&gt;Iterator&lt;/code&gt;を返すべきで、その場合以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator found = Map.search(&amp;quot;Jeffrey&amp;quot;);
if (!found.hasNext()) {
  throw new EmployeeNotFoundException();
}
return found.next();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに、C++の標準ライブラリの&lt;a href=&#34;http://www.cppll.jp/cppreference/cppmap_details.html&#34;&gt;map::find()&lt;/a&gt;はまさにこのように設計されている。&lt;/p&gt;

&lt;h3 id=&#34;コンピュータ思考-vs-オブジェクト思考:08adb1e15fed47fdc6706e8240d4bde7&#34;&gt;コンピュータ思考 vs. オブジェクト思考&lt;/h3&gt;

&lt;p&gt;Javaのオブジェクトはデータ構造を指すポインタで、&lt;code&gt;NULL&lt;/code&gt;は何も指さないポインタ(Intel x86プロセッサでは0x00000000)であることを知っている人にとっては、&lt;code&gt;if (employee == null)&lt;/code&gt;という文は理解できる。&lt;/p&gt;

&lt;p&gt;しかし、もし君がオブジェクトになって考えたとすると、この文はかなり意味のないものになる。オブジェクト視点で上記コードは以下のように見える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;- もしもし、ソフトウェア部ですか?
- はい。
- Jeffreyと話したいのですが。
- 少々お待ちください。。。
- もしもし。
- あなたはNULLですか?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会話の最後の質問が変だろ?&lt;/p&gt;

&lt;p&gt;代わりに、もしJeffreyへの取り次ぎをお願いした後で電話が切れたら、自分に問題(例外)が発生した、ということにする。
この時点で、もう一度電話してみるか、Jeffreyにつながらないので仕事が進みませんと上司に報告する。&lt;/p&gt;

&lt;p&gt;あるいは、ソフトウェア部の人が、Jeffreyではないがだいたいの質問に答えられる人に取り次いでくれるかもしれないし、
Jeffreyにしかわからない用事だから無理、と拒否してくるかもしれない(Nullオブジェクト)。&lt;/p&gt;

&lt;h3 id=&#34;遅いエラー:08adb1e15fed47fdc6706e8240d4bde7&#34;&gt;遅いエラー&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;な&lt;code&gt;getByName()&lt;/code&gt;に対して、Nullオブジェクトを使った方はゆっくり死のうとしている。途中で他のものを殺しながら。
問題が発生したので例外処理をすぐに始めるべきだと周りに知らせる代わりに、クライアントからエラーを隠している。&lt;/p&gt;

&lt;p&gt;この議論は、前述した「アドホックエラー処理」に近い。&lt;/p&gt;

&lt;p&gt;コードはできるだけもろい方がいい。必要なときに壊れるように。&lt;/p&gt;

&lt;p&gt;メソッドを、それが扱うデータに対してできるだけ厳しくさせ、与えられたデータに不備があったりメソッドの使用方法に反していたら、例外を投げるようにすべきだ。&lt;/p&gt;

&lt;p&gt;もしくは、共通的な挙動をする他は常に例外を投げるNullオブジェクトを返すべきだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  Employee employee;
  if (id == 0) {
    employee = new Employee() {
      @Override
      public String name() {
        return &amp;quot;anonymous&amp;quot;;
      }
      @Override
      public void transferTo(Department dept) {
        throw new AnonymousEmployeeException(
          &amp;quot;I can&#39;t be transferred, I&#39;m anonymous&amp;quot;
        );
      }
    };
  } else {
    employee = Employee(id);
  }
  return employee;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可変で不完全なオブジェクト:08adb1e15fed47fdc6706e8240d4bde7&#34;&gt;可変で不完全なオブジェクト&lt;/h3&gt;

&lt;p&gt;一般的に、オブジェクトは&lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;不変的&lt;/a&gt;に設計することが望ましい。
これはつまり、オブジェクトはインスタンス化の際に必要な情報を全て受け取り、その後そのライフサイクル全体に渡ってその状態を変えないということだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF&#34;&gt;遅延読み込み&lt;/a&gt;をする際によく使われ、オブジェクトを不完全で可変にしてしまう。以下が例だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Department {
  private Employee found = null;
  public synchronized Employee manager() {
    if (this.found == null) {
      this.found = new Employee(&amp;quot;Jeffrey&amp;quot;);
    }
    return this.found;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この手法は、広く使われてはいるが、OOPにおけるアンチパターンだ。
主な理由は、実行環境の性能問題の責任をオブジェクトに負わせているからだ。本来それは&lt;code&gt;Employee&lt;/code&gt;オブジェクトが気にすべきことではない。&lt;/p&gt;

&lt;p&gt;オブジェクトが、自身の状態を管理して、自身の役割に関するふるまいを公開する代わりに、戻り値のキャッシュの面倒を見なければいけない。これが遅延読み込みというものだ。&lt;/p&gt;

&lt;p&gt;キャッシュはemployee(従業員)がオフィスでするようなことじゃないだろ?&lt;/p&gt;

&lt;p&gt;解決策?
遅延読み込みを上記の例みたいな原始的な方法でやらないことだ。代わりに、キャッシュ処理をアプリケーションの他のレイヤに移せばいい。&lt;/p&gt;

&lt;p&gt;たとえば、Javaなら、アスペクト指向プログラミングのアスペクトが使える。
たとえば、&lt;a href=&#34;http://aspects.jcabi.com/&#34;&gt;jcabi-aspects&lt;/a&gt;には&lt;code&gt;&lt;a href=&#34;http://aspects.jcabi.com/annotation-cacheable.html&#34;&gt;@Cacheable&lt;/a&gt;&lt;/code&gt;というアノテーションがあり、メソッドの戻り値をキャッシュできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.jcabi.aspects.Cacheable;
public class Department {
  @Cacheable(forever = true)
  public Employee manager() {
    return new Employee(&amp;quot;Jacky Brown&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;君がこの分析に納得して&lt;code&gt;NULL&lt;/code&gt;を使うのをやめることを願う。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;http://www.youtube.com/embed/o3aNJX7AP3M&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Nullを使っちゃだめという意見はめずらしくないが、その根拠をコードの信頼性、可読性といった技術的な側面からだけでなく、
オブジェクト界に降り立って見たときに感じる違和感というオブジェクト哲学的な側面からも説明する辺りが面白い。&lt;/p&gt;

&lt;p&gt;まあNullを完全に使わないという境地には、少なくともJavaのコードでは一生たどり着ける気がしないが。
メソッドの先頭で引数のNullチェックをするとかもダメなんだろうか。それがダメだとフェイルファストができなかったり、メッセージのないNullPointerExceptionが発生したりして微妙。
あ、フルスクラッチで完全に自己完結したアプリケーションを作る場合の話か。それならそもそもNullを渡すなという話にしかならないか。&lt;/p&gt;

&lt;p&gt;自分で書くクラスやライブラリについて、Nullは内部的には使うけど、APIには一切Nullを返させない、くらいなら実現するのは難しくなさそうだし、やったほうがいい気もする。(この場合遅延読み込みで一時的にNullをセットしておくのはあり。)
ただ、性能を考えた場合は、例えばエラー処理はアドホックが一番軽くて、次にNullオブジェクトパターンで、例外はちょっと重めという風になるだろうから、Nullを返したくなることもありそう。&lt;/p&gt;

&lt;p&gt;ことあるごとに例外を投げてくるAPIは使う側にとってはうっとうしいしなぁ。
多彩な例外を投げ分けるJavaのリフレクションみたいなのは、使うとコードが散らかってかなわん。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Getter/Setterは悪だ。以上。</title>
          <link>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</link>
          <pubDate>Wed, 22 Jul 2015 00:21:15 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2003年にAllen Holubが書いた&lt;a href=&#34;http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html&#34;&gt;Why getter and setter methods are evil&lt;/a&gt;という有名な記事に端を発する古い議論がある。それは、getter/setterはアンチパターンで避けるべきものなのか、
もしくはオブジェクト指向プログラミングに必須なものなのかというもの。
この議論に少しだけ私の意見を加えたいと思う。&lt;/p&gt;

&lt;p&gt;上記記事の要旨はこうだ。
getterやsetterはひどい慣習で、これらを使うやつらはゆるせん。誤解の無いようもう一度言うが、
私はget/setを可能な限り避けるべきだと言っているのではない。それらは君のコードに決して現れてはいけないのだ。&lt;/p&gt;

&lt;p&gt;横柄で目につく物言いだろう?
君は15年来get/setパターンを使い続けている尊敬を集めるJavaアーキテクトなんだろう?
どこぞの馬の骨にこんなデタラメを言われたくはないだろう?
ああ、その気持ちはわかる。私がDavid Westの&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;という本に出会ったとき、
私もほとんど同じことを感じた。
Object Thinkingは、私が今まで読んだオブジェクト指向プログラミングについての本の中で最高のものだ。
だからお願いだ。ひとまず落ち着いて。私に説明させてほしい。&lt;/p&gt;

&lt;h3 id=&#34;既存の論拠:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;既存の論拠&lt;/h3&gt;

&lt;p&gt;オブジェクト指向の世界で、アクセッサ(getterやsetterの別名)に反対する論拠はいくつかあるが、
私にはそれら全てが十分に有力であるとは思えない。ひとつひとつ簡単に見ていこう。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;頼め、尋ねるな&lt;/p&gt;

&lt;p&gt;Allen Holub曰く、「ある処理をする際、その処理のために君が欲しい情報をオブジェクトに尋ねてはいけない。
その情報を持ったオブジェクトにその処理をするよう頼みなさい。」&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;カプセル化原則違反&lt;/p&gt;

&lt;p&gt;setterを通してどんな新たなデータも入力できるので、
一つのオブジェクトをその他の様々なオブジェクトが様々に扱うことができてしまう。
また、だれでもオブジェクトを変更できるので、
オブジェクトが単純に自身の状態を安全にカプセル化できない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;実装の詳細の暴露&lt;/p&gt;

&lt;p&gt;あるオブジェクトから他のオブジェクトを取得できる場合、前者のオブジェクトの実装の詳細に過度に依存してしまう。
もし明日その実装、例えば返すオブジェクトの型が変わったら、周辺のコードも書き換えないといけない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これらの全ての論拠は正当だが、重要なポイントが抜けている。&lt;/p&gt;

&lt;h3 id=&#34;根本的な誤解:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;根本的な誤解&lt;/h3&gt;

&lt;p&gt;ほとんどのプログラマはオブジェクトはメソッドを持ったデータ構造だと考えている。
ここでBozhidar Bozhanovによる記事、&lt;a href=&#34;https://dzone.com/articles/getters-and-setters-are-not&#34;&gt;Getters and Setters Are Not Evil&lt;/a&gt;から引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;しかし、人々がgetterやsetterをつけるオブジェクトのほとんどが、単純なデータホルダだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この思い違いが巨大な誤解の結果だ!
オブジェクトは単純なデータホルダではない。オブジェクトはメソッド付きのデータ構造ではない。
このデータホルダというコンセプトは、CやCOBOLといった手続き型言語からオブジェクト指向プログラミングに持ち込まれたものだ。
もう一度言う。オブジェクトはデータとそれを操作する関数をセットにしたものではない。
オブジェクトはデータエンティティではない。では何か?&lt;/p&gt;

&lt;h3 id=&#34;ボールと犬:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;ボールと犬&lt;/h3&gt;

&lt;p&gt;真のオブジェクト指向プログラミングでは、
オブジェクトは&lt;a href=&#34;http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html&#34;&gt;生きている生物&lt;/a&gt;だ。私や君と同じように。
オブジェクトは生きている有機体で、それ自身の挙動や、特性や、ライフサイクルを持っている。&lt;/p&gt;

&lt;p&gt;生きている有機体はsetterを持てるだろうか? 犬にボールを&amp;rdquo;set&amp;rdquo;できるだろうか? 無理だろう。
だが、以下のコードはまさにそれをしている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setBall(new Ball());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどう感じる?&lt;/p&gt;

&lt;p&gt;また、ボールを犬から取得できるだろうか?
まあ、できるかもしれない、もしその犬がボールを食べて、君が手術をするのであれば。
この場合、確かに、犬からボールを&amp;rdquo;get&amp;rdquo;できる。以下のコードが今話したようなことをやっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
Ball ball = dog.getBall();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またさらにばかげた例がこれだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setWeight(&amp;quot;23kg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現実世界でこの処理がどんなか想像できるかな?&lt;/p&gt;

&lt;p&gt;君が毎日書いているコードはこれに似ているかい?
もしそうなら、君は手続き型プログラマだ。認めなさい。
David Westが彼の本の30ページでそれについて以下のように言っている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;成功した手続き型開発者が成功するオブジェクト開発者に移行するための最初のステップは、ロボトミーだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;君はロボトミーが必要か？
因みに、WestのObject Thinkingを読んでいた時、私には明らかに必要だったので受けた。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト思考:c4cf7c15f2f4f7b33a72f14d578b7e41&#34;&gt;オブジェクト思考&lt;/h3&gt;

&lt;p&gt;オブジェクト思考を開始すると、君は即座にメソッド名を変更し、多分以下のコードに辿り着く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.take(new Ball());
Ball ball = dog.give();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、私たちは犬を実際の動物として扱っている。この犬は、ボールを私たちから受け取り、頼めば返してくれる。
ここで特筆すべきは、この犬は &lt;code&gt;NULL&lt;/code&gt; を返すことはできない。犬は &lt;code&gt;NULL&lt;/code&gt; が何なのかなんて知らないからね。オブジェクト思考は即座に&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;NULL参照&lt;/a&gt;をコードから排除する。&lt;/p&gt;

&lt;p&gt;さらに、オブジェクト思考はオブジェクト不変性につながる。
犬の体重の例を、君は以下のように書き換えるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog(&amp;quot;23kg&amp;quot;);
int weight = dog.weight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この犬は不変な生きた有機体であり、だれも外からその体重やサイズや名前などを変更することはできない。
この犬は要求に応じて体重や名前を教えてくれる。
オブジェクトの中身を要求するパブリックメソッドには何の問題もないが、
こういったメソッドは&amp;rdquo;getter&amp;rdquo;ではなく、&amp;rdquo;get&amp;rdquo;というプレフィックスは決して付かない。
私たちは犬から何かを取ろうというのではない。犬から名前を取るのではなく、犬に名前を教えてくれるよう頼むのだ。
この違いが分かるかな?&lt;/p&gt;

&lt;p&gt;語義論の話をしているというわけでもない。
手続き型プログラミング思考とオブジェクト指向プログラミング思考とを区別しようというのだ。
手続き型プログラミングでは、私たちはデータを扱い、必要に応じてそれを操作したり取得したりセットしたり消したりする。
私たちはデータの責任者で、そのデータは単なる受動的なコンポーネントだ。
犬は私たちとは何の関係もなく、ただのデータホルダだ。それは生命を持っていない。
私たちはそれから必要なものを何でも自由に取得できるし、どんなデータでもセットすることができる。
これがCやCOBOLやPascalなどの手続き型言語のやりかただ。&lt;/p&gt;

&lt;p&gt;それに対して、真のオブジェクト指向の世界では、オブジェクトを生きた有機体のように扱い、
オブジェクトには生まれた日と死ぬ瞬間がある。また、君が望むなら、アイデンティティや性質を持たせてもいい。
犬にはデータの一部(例えば体重)をくれるよう頼むことができるし、犬はその情報を返してもよい。
ただ、この犬は能動的なコンポーネントであることを忘れてはいけない。
こちらの要求に対し、何をするかは犬が決めるのだ。&lt;/p&gt;

&lt;p&gt;以上が、getやsetで始まるメソッドをオブジェクトに持たせることが概念的に間違っている理由だ。
それは、多くの人々が主張するように、カプセル化を崩すということではない。
それは、君がオブジェクト的な思考をしているか、もしくは今だCOBOLをJavaのシンタックスで書いているかということだ。&lt;/p&gt;

&lt;p&gt;追伸: そうだ、君はこう尋ねるかもしれない。JavaBeans、JPA、JAXBなどのget/set表記に頼るJava APIはどうなんだ?
Rubyに付属するアクセッサ生成を簡易化する機能は?
ああ、それらは全て私たちにとっての不幸だ。
手続き型COBOLの原始的な世界に留まることは、真のオブジェクトからなる美しい世界を正しく理解し感謝するのに比べてはるかに簡単だ。&lt;/p&gt;

&lt;p&gt;追追伸: 言い忘れたが、setterを使った依存性注入もひどいアンチパターンだ。
それについてはいずれ書く。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;http://www.youtube.com/embed/WSgP85kr6eU&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Javaを始めた当初から今まで、Getter/Setterは絶対正義だと信じ、クラスを作れば無心でIDEの言いなりにそれを生成していたので、
この記事はなかなかに刺激的だった。(まあfinalなフィールドが好きなのでsetterの方はあまり作らなかったが。)&lt;/p&gt;

&lt;p&gt;ただ、記事の本質としては、Getter/Setterパターン、つまり、
オブジェクトのフィールドをprivateにし、メソッドを介してアクセスさせるようにすることで、実装の詳細を隠蔽し、
APIと分離させることを図るデザインパターンの技術的役割や目的を否定しているわけではなく、
オブジェクト指向の哲学的な部分にも則り、Getter/Setterパターンを真のオブジェクト界に向けて昇華させましょうと言っているように読める。&lt;/p&gt;

&lt;p&gt;犬とボールのやり取りをするコードのビフォーアフターはsetBall/getBallがtake/giveになっただけで、
これだけ見れば処理が変わるわけでもないし、コンパイラに言わせればどっちでもいいだろとなる。
ただ、プログラマにボールを無下につっこまれるビフォーの犬よりも、
自ら能動的にボールを受け取り返してくれるアフターの犬の方が幸せそうで愛らしいのは確かだ。
真のオブジェクト界を垣間見た気がする。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>First Post</title>
          <link>http://tbd.kaitoy.xyz/2015/07/18/first-post/</link>
          <pubDate>Sat, 18 Jul 2015 13:10:37 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/18/first-post/</guid>
          <description>&lt;p&gt;初投稿。&lt;/p&gt;

&lt;p&gt;ブログを立ち上げようと思ったきっかけは、&lt;a href=&#34;https://www.google.co.jp/search?q=teamed.io&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;hl=ja&#34;&gt;Teamed.io&lt;/a&gt;というCaliforniaのソフトウェアアウトソーシング(?)をやってる会社のCTO、
Yegor Bugayenko (yegor256)のブログのエントリ、&lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html&#34;&gt;How Much Do You Cost?&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これは、Teamed.ioがエンジニアに払うfeeを決める際の指標についてのエントリで、その指標の一つとして &lt;em&gt;Talks and Publications&lt;/em&gt; を挙げている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Both blog articles and conference presentations make you much more valuable as a specialist.
Mostly because these things demonstrate that some people already reviewed your work and your talent.
And it was not just a single employer, but a group of other programmers and engineers.
This means that we also can rely on your opinions.&lt;/p&gt;

&lt;div style=&#34;font-size: 0.5em; text-align: right;&#34;&gt;&lt;cite&gt;引用元: &lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&#34;&gt;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&lt;/a&gt;&lt;/cite&gt;&lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;つまり、カンファレンスで発表したりブログで意見を発信すると、それらを見た様々な人たちによってレビューされフィードバックを受けることになるので、
そういった経験が多いエンジニアは、より洗練された考えや技術を持っているとみなせるということ。&lt;/p&gt;

&lt;p&gt;確かに、普段会社の同僚としか接しないので、自分の意見を広く発信してフィードバックを受けるのは刺激になりおもしろそうだしためになりそう。
ただそのためにはこのブログが広く読まれコメントをもらえるまでになる必要があるが、それはさておき、
文筆の練習として、また物事に対する理解を深めるためにも、書くということは有益であろう。備忘録にもなるし。&lt;/p&gt;

&lt;p&gt;因みに、Yegorはオブジェクト指向プログラミングの原理主義者で、ソフトウェア開発に対して非常に厳格で斬新な(異端な?)考え方を持っている。
それは例えば彼の以下のブログエントリに見られる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt; (スタンドアップミーティングはダメマネージャーが好む手法)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html&#34;&gt;ORM Is an Offensive Anti-Pattern&lt;/a&gt; (ORMはけしからんアンチパターン)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt; (GetterやSetterは悪だ。以上。)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下で働くと苦労しそうなタイプな気はするが、言っていることは面白いし説得力もあるので、いくつかのエントリを和訳しておいおいここで紹介していこうかと思う。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
