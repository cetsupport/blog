<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>http://tbd.kaitoy.xyz/tags/git/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2016</rights>
    <updated>2016-01-01 18:38:02 -0700 MST</updated>

    
      
        <item>
          <title>git resetとrevertを図解する</title>
          <link>http://tbd.kaitoy.xyz/2016/01/01/git-revert-reset/</link>
          <pubDate>Fri, 01 Jan 2016 18:38:02 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2016/01/01/git-revert-reset/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/27/git-repository/&#34;&gt;この記事&lt;/a&gt;を読んだことを前提に、&lt;a href=&#34;https://git-scm.com/&#34;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/a&gt;の &lt;code&gt;git revert&lt;/code&gt; と &lt;code&gt;git reset&lt;/code&gt;というコマンドについて説明する。
この二つはしばしばコミットを取り消すコマンドとして同じ文脈で説明されることが多いのでこのエントリでも一緒に説明するが、実際は全く異なるコマンドだし、そもそもどちらもコミットを取り消すコマンドではない。&lt;/p&gt;

&lt;h2 id=&#34;git-revert&#34;&gt;git revert&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt;は、指定したコミットが持ち込んだ変更を打ち消すコミットを追加する。
リバースパッチを適用すると言ってもよい。
コミットを追加しかしないので、このコマンドによって既存のコミットが消えたり変わったりすることはない。&lt;/p&gt;

&lt;p&gt;図にすると以下の感じ。単純。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_revert/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_revert/スライド2.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-reset&#34;&gt;git reset&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt;には二つの機能がある。
インデックスを再設定する(i.e. resetする)機能と、&lt;code&gt;HEAD&lt;/code&gt;を付け替える(i.e. resetする)機能だ。&lt;/p&gt;

&lt;h4 id=&#34;インデックスの再設定&#34;&gt;インデックスの再設定&lt;/h4&gt;

&lt;p&gt;インデックスの再設定をするコマンドは&lt;code&gt;git reset &amp;lt;ワーキングディレクトリ内のファイルのパス(複数可)&amp;gt;&lt;/code&gt;。
これを実行すると、指定したファイルについて、&lt;code&gt;HEAD&lt;/code&gt;が指すコミットが指すツリー内のブロブを指すようインデックスを更新する。&lt;/p&gt;

&lt;p&gt;何を言っているのかわからないので図にする。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_path/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_path/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_path/スライド3.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;図を見ると、&lt;code&gt;git add Readme.md&lt;/code&gt;と&lt;code&gt;git reset Readme.md&lt;/code&gt;がだいたい逆のことをしていることがわかる。
要するに、&lt;code&gt;git add &amp;lt;パス&amp;gt;&lt;/code&gt;は指定したファイルをステージし、&lt;code&gt;git reset &amp;lt;パス&amp;gt;&lt;/code&gt;は指定したファイルをアンステージする。&lt;/p&gt;

&lt;h4 id=&#34;headの付け替え&#34;&gt;HEADの付け替え&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;の付け替えをするコマンドは&lt;code&gt;git reset &amp;lt;コミット&amp;gt;&lt;/code&gt;。
これを実行すると、&lt;code&gt;HEAD&lt;/code&gt;が指しているコミットを指すよう&lt;code&gt;ORIG_HEAD&lt;/code&gt;を作成または更新し、指定したコミットを指すよう&lt;code&gt;HEAD&lt;/code&gt;を更新する。
オプションによってはさらにインデックスやワーキングディレクトリを指定したコミットが指すツリーと同期するよう更新する。&lt;/p&gt;

&lt;p&gt;このオプションには&lt;code&gt;--soft&lt;/code&gt;、&lt;code&gt;--mixed&lt;/code&gt; (デフォルト)、&lt;code&gt;--hard&lt;/code&gt;の三種類があり、それぞれのオプションを付けた時の更新対象を次の表に示す。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;オプション&lt;/th&gt;
&lt;th&gt;HEAD&lt;/th&gt;
&lt;th&gt;インデックス&lt;/th&gt;
&lt;th&gt;ワーキングディレクトリ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;--soft&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;--mixed&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;--hard&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この三者の違いについては面倒だしだいたい分かるはずなので図にしないが、&lt;code&gt;git reset &amp;lt;コミット&amp;gt;&lt;/code&gt;したときの&lt;code&gt;HEAD&lt;/code&gt;動きについて次に図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_commit/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_commit/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-revert-reset/git_reset_commit/スライド3.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スライド中で&lt;code&gt;git reset HEAD^&lt;/code&gt;した時点で、コミットDは実質的に削除されたに近い状態になる。
&lt;code&gt;ORIG_HEAD&lt;/code&gt;という一時的なシンボリック参照で指されているだけで、どの参照からもたどり着けなくなるからだ。
コミットDはいずれ&lt;code&gt;git gc&lt;/code&gt;によって実際に削除されるはずだし、&lt;code&gt;git push&lt;/code&gt;してもコミットD、それが指すツリー、そのツリーの下にしかないブロブはリモートリポジトリに送られない。&lt;/p&gt;

&lt;p&gt;よって、&lt;code&gt;git reset &amp;lt;コミット&amp;gt;&lt;/code&gt;は普通コミットを削除したいときに使われる。
使われはするが、このコマンド自体がコミットを削除するわけではなくて、あくまで&lt;code&gt;HEAD&lt;/code&gt;を付け替えるコマンドであることを覚えていた方がいざというときに助かる。&lt;/p&gt;

&lt;p&gt;因みに上のスライドでやった操作は、&lt;code&gt;git commit --amend&lt;/code&gt;がやることとほぼ同じ。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Gitの分散バージョン管理の仕組み</title>
          <link>http://tbd.kaitoy.xyz/2015/12/31/git-dvc/</link>
          <pubDate>Thu, 31 Dec 2015 01:02:59 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/31/git-dvc/</guid>
          <description>

&lt;p&gt;このエントリでは、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/27/git-repository/&#34;&gt;この記事&lt;/a&gt;を読んだことを前提に、&lt;a href=&#34;https://git-scm.com/&#34;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/a&gt;の分散バージョン管理の仕組みについて説明する。&lt;/p&gt;

&lt;h2 id=&#34;gitの分散バージョン管理&#34;&gt;Gitの分散バージョン管理&lt;/h2&gt;

&lt;p&gt;分散バージョン管理とは、分散したリポジトリでのバージョン管理ということ。
ここでリポジトリが分散しているとは、同じプロジェクトの履歴を管理する完全で独立したリポジトリが複数あるということ。
これにより一つのプロジェクトの開発を地理的に分散して並行して進めることができる。&lt;/p&gt;

&lt;p&gt;Gitは分散バージョン管理のために、リポジトリのクローン(≒コピー)を作る機能と、リポジトリ間でコミットグラフを同期する機能を提供している。&lt;/p&gt;

&lt;p&gt;リポジトリのクローンを作ると言うと、オリジナルとクローンの間に格差があるような気がするが、
実際にはGitは全てのリポジトリが対等であるという思想のもとで実装されている。
このため、リポジトリをクローンする時には(デフォルトで)クローン元の完全なコミットグラフがクローンにコピーされるし、任意のリポジトリ間のデータのやり取りをpeer-to-peerでできる。
クローンからクローンを作ることももちろん可能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;でデータを送る先をアップストリームと呼ぶことはあるし、次節でローカルリポジトリとリモートリポジトリという関係が出てくるが、これはあくまでその時点でそういう設定になっているというだけ。
アップストリームはいつでもいくつでも&lt;code&gt;git remote&lt;/code&gt;コマンドで追加したり削除したりできる。&lt;/p&gt;

&lt;p&gt;このような実装により、Gitの分散バージョン管理ではリポジトリ間で柔軟なデータのやり取りができる。
例えば以下の様な複雑なリポジトリネットワークを組むこともできる。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-2.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/repo_net.png&#34; style=&#34;width: 100%; max-width: 400px; margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;ローカルリポジトリとリモートリポジトリ&#34;&gt;ローカルリポジトリとリモートリポジトリ&lt;/h2&gt;

&lt;p&gt;一人の開発者から見て、手元にあるリポジトリを &lt;strong&gt;ローカルリポジトリ&lt;/strong&gt; と呼ぶのに対して、&lt;code&gt;git push&lt;/code&gt;や&lt;code&gt;git pull&lt;/code&gt;や&lt;code&gt;git fetch&lt;/code&gt;でデータをやり取りする相手のリポジトリを &lt;strong&gt;リモートリポジトリ&lt;/strong&gt; と呼ぶ。
リモートリポジトリとのやり取りは、&lt;strong&gt;リモート追跡ブランチ&lt;/strong&gt; と &lt;strong&gt;リモート&lt;/strong&gt; というものを使って実装されている。&lt;/p&gt;

&lt;h4 id=&#34;リモート追跡ブランチ&#34;&gt;リモート追跡ブランチ&lt;/h4&gt;

&lt;p&gt;リモート追跡ブランチは、ローカルリポジトリの&lt;code&gt;.git/refs/remotes/&lt;/code&gt;に格納される参照で、リモートリポジトリ内のローカルブランチのコミットグラフを取得してローカルリポジトリ内に保持するために使われる。
&lt;code&gt;git branch -r&lt;/code&gt;でその一覧が見れる。&lt;/p&gt;

&lt;p&gt;「追跡」ブランチというだけあって、リモートリポジトリ内でコミットグラフが成長した場合、この変更に追随することができる。
このためのコマンドが&lt;code&gt;git fetch&lt;/code&gt;。
因みに&lt;code&gt;git pull&lt;/code&gt;は、&lt;code&gt;git fetch&lt;/code&gt;でリモート追跡ブランチを更新した後、&lt;code&gt;git merge&lt;/code&gt;(オプションによっては&lt;code&gt;git rebase&lt;/code&gt;)でそのリモート追跡ブランチをローカルブランチにマージするのと同じ。&lt;/p&gt;

&lt;h4 id=&#34;リモート&#34;&gt;リモート&lt;/h4&gt;

&lt;p&gt;リモートとは、リモートリポジトリのこと、またはリモートリポジトリに接続するための定義のこと。
この定義は、ローカルリポジトリの&lt;code&gt;.git/config&lt;/code&gt;に&lt;code&gt;remote&lt;/code&gt;セクションとして書かれている。
以下がその例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[remote &amp;quot;origin&amp;quot;]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = git@github.com:kaitoy/blog.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セクション名のところに&lt;code&gt;&amp;quot;origin&amp;quot;&lt;/code&gt;とあるがこれは、この定義で接続するリモートリポジトリをGitコマンドなどで&lt;code&gt;origin&lt;/code&gt;と指定できるということ。
ここで定義されているのは&lt;code&gt;url&lt;/code&gt;と&lt;code&gt;fetch&lt;/code&gt;で、それぞれ以下を意味する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;url&lt;/p&gt;

&lt;p&gt;リモートリポジトリのURL。
つまり、リモートリポジトリがどのサーバのどのディレクトリにあって、それとのデータのやり取りをどのプロトコルでやるかという定義。
このURLには以下の書式が使える。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ファイルパス&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/path/to/repo.git&lt;/code&gt;とか&lt;code&gt;C:\\Users\\Kaito\\Desktop\\pcap4j&lt;/code&gt;といった、普通のファイルパスの書式。
&lt;a href=&#34;https://ja.wikipedia.org/wiki/Network_File_System&#34;&gt;NFS&lt;/a&gt;などでリモートリポジトリが共有されている場合などに使われる。&lt;/p&gt;

&lt;p&gt;シンボリックリンクがサポートされているOS上では、クローンはリモートリポジトリをハードリンクで参照する。
このシンボリック参照でのファイル共有がトラブルの元なため、この書式は非推奨。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;ファイルURL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;file:///path/to/repo.git&lt;/code&gt;とか&lt;code&gt;file://C:/Users/Kaito/Desktop/pcap4j&lt;/code&gt;といった、ローカルホスト上のパスを示すファイルURLの書式。
用途はファイルパスと同様だが、ハードリンクを作る代わりにコピーするのでより安全。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;HTTP(S)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://github.com/kaitoy/pcap4j.git&lt;/code&gt;といったHTTPSやHTTPのURL。
リポジトリへのアクセス制御にHTTPの認証機能やHTTPSのクライアント証明書などが使えるほか、HTTPSなら通信の暗号化もできる。&lt;/p&gt;

&lt;p&gt;使用するポートがファイアウォールにブロックされていることが少ないのも使いやすい。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Gitプロトコル&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git://example.com/path/to/repo.git&lt;/code&gt;といった書式で、&lt;a href=&#34;https://git-scm.com/book/ja/v1/Git-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC-Git-%E3%83%87%E3%83%BC%E3%83%A2%E3%83%B3&#34;&gt;Gitデーモン&lt;/a&gt;によるGitネイティブプロトコルを使うURL。
HTTPよりも高速な通信ができるが、認証機能も暗号化機能もない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;SSH + Gitプロトコル&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh://git@github.com/kaitoy/pcap4j.git&lt;/code&gt;のような&lt;a href=&#34;https://ja.wikipedia.org/wiki/Secure_Shell&#34;&gt;SSH&lt;/a&gt;のURLで、これを使うとSSHトンネルを通してGitプロトコルで通信できる。
Gitプロトコル単体を使うのに比べ、SSHの認証機能と暗号化機能を利用できるが、やや遅くなるはず。&lt;/p&gt;

&lt;p&gt;このプロトコルには、&lt;code&gt;git@github.com:kaitoy/pcap4j.git&lt;/code&gt;のような&lt;a href=&#34;https://ja.wikipedia.org/wiki/Secure_copy&#34;&gt;SCP&lt;/a&gt;書式も使える。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Git自体はGitデーモンを含めリポジトリへのアクセス制御の機能を一切持たないので、認証などが必要な場合はHTTPなどその機能を持つプロトコルのURLを使う必要がある。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fetch&lt;/p&gt;

&lt;p&gt;リモートリポジトリ内のローカルブランチとローカルリポジトリ内の追跡ブランチとがどう対応するかを定義する。
この定義は&lt;code&gt;refspec&lt;/code&gt;と呼ばれる。&lt;/p&gt;

&lt;p&gt;上の例の&lt;code&gt;fetch = +refs/heads/*:refs/remotes/origin/*&lt;/code&gt;だと、リモートリポジトリの&lt;code&gt;.git/refs/heads/&lt;/code&gt;にある全てのブランチをそれぞれ、ローカルリポジトリの&lt;code&gt;.git/refs/remotes/origin/&lt;/code&gt;にある同名のブランチで追跡する、という意味。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;クローン時の挙動&#34;&gt;クローン時の挙動&lt;/h2&gt;

&lt;p&gt;クローン時のデフォルトの挙動について説明する。&lt;/p&gt;

&lt;p&gt;リポジトリのクローンを作ると、オブジェクト格納領域内のオブジェクトが全てクローンにコピーされる。
つまり、元のリポジトリ(i.e. リモートリポジトリ)と同じコミットグラフ(とタグオブジェクト)がクローンのリポジトリに入る。&lt;/p&gt;

&lt;p&gt;インデックスはリポジトリ毎に固有の一時的なデータなので、クローンにはコピーされない。&lt;/p&gt;

&lt;p&gt;参照については、リモートリポジトリ内の全てのローカルブランチとタグがクローンにコピーされる。&lt;/p&gt;

&lt;p&gt;リモート追跡ブランチはコピーされず、代わりに、リモートリポジトリ内の全てのローカルブランチに対応する同名のリモート追跡ブランチがクローンのリポジトリ内に作成される。
また、これに対応するリモートが作成され、これの&lt;code&gt;fetch&lt;/code&gt;に(前節の例と同様に)&lt;code&gt;+refs/heads/*:refs/remotes/origin/*&lt;/code&gt;が設定される。&lt;/p&gt;

&lt;p&gt;シンボリック参照はリポジトリ毎に固有のものなのでクローンにはコピーされない。
クローンにはデフォルトブランチ(普通は&lt;code&gt;master&lt;/code&gt;)を指す&lt;code&gt;HEAD&lt;/code&gt;が作成される。&lt;/p&gt;

&lt;h2 id=&#34;リモートリポジトリとのやり取りの図解&#34;&gt;リモートリポジトリとのやり取りの図解&lt;/h2&gt;

&lt;p&gt;リモートリポジトリをクローンして、変更をプルしたりプッシュしたりする様子を以下に図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド4.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド5.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_merge/スライド6.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはこれで完全に正しい手順だが、最終的にできるコミットグラフが無駄に分岐していて美しくない。
普通は以下の様に、リベースを挟んで一直線の履歴に保つ方が一般にいいと思う。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_ff/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_ff/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_ff/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-dvc/git_dvc_ff/スライド4.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このフェッチ + リベースを一度にやってくれるのが、&lt;code&gt;git pull --rebase&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;gitで分散バージョン管理する際の注意点&#34;&gt;Gitで分散バージョン管理する際の注意点&lt;/h2&gt;

&lt;p&gt;Gitで分散バージョン管理する際の注意点を二つ挙げる。&lt;/p&gt;

&lt;h4 id=&#34;他のリポジトリにもあるコミットを変更してはいけない&#34;&gt;他のリポジトリにもあるコミットを変更してはいけない&lt;/h4&gt;

&lt;p&gt;Gitには、&lt;code&gt;git commit --amend&lt;/code&gt;、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/28/git-merge/#%E3%83%AA%E3%83%99%E3%83%BC%E3%82%B9&#34;&gt;&lt;code&gt;git rebase&lt;/code&gt;&lt;/a&gt;といったコミットを変更するコマンドや、&lt;a href=&#34;http://tbd.kaitoy.xyz/2016/01/01/git-revert-reset/#git-reset&#34;&gt;&lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;というコミットの削除につながるコマンドがある。
こういうコマンドで他のリポジトリにもあるコミットを変更してはいけない。&lt;/p&gt;

&lt;p&gt;他のリポジトリにもあるコミットとは、クローン時にコピーしてきたコミット、プルしたコミット、プッシュしたコミットなどのこと。&lt;/p&gt;

&lt;p&gt;もしやると、プッシュもプルも簡単にはできなくなり非常に面倒なことになる。&lt;/p&gt;

&lt;h4 id=&#34;開発リポジトリには-基本的に-プッシュしてはいけない&#34;&gt;開発リポジトリには(基本的に)プッシュしてはいけない&lt;/h4&gt;

&lt;p&gt;リポジトリには、&lt;strong&gt;ベアリポジトリ&lt;/strong&gt; と、&lt;strong&gt;開発リポジトリ&lt;/strong&gt; がある。
開発リポジトリは普段使っている普通のリポジトリ。
ベアリポジトリは、簡単に言うとワーキングディレクトリやカレントブランチやリモートを持たないリポジトリで、開発リポジトリのリモートリポジトリとして使われ、&lt;code&gt;git init&lt;/code&gt;や&lt;code&gt;git clone&lt;/code&gt;に&lt;code&gt;--bare&lt;/code&gt;オプションを付けて実行すると作れる。&lt;/p&gt;

&lt;p&gt;ベアリポジトリにはプッシュしていい。
むしろプッシュしないベアリポジトリに意味はない。&lt;/p&gt;

&lt;p&gt;一方、開発リポジトリには(基本的に)プッシュしてはいけない。
これは、プッシュがリモートリポジトリのオブジェクトと参照だけ更新してワーキングディレクトリやインデックスは更新せず、開発者がプッシュされたことに気付けないため(※1)。
気付かないまま開発を進めてコミットを作ると、プッシュによって&lt;code&gt;HEAD&lt;/code&gt;が変わっていたりするため、コミットグラフが変な状態になってしまう。&lt;/p&gt;

&lt;p&gt;お互い示し合わせたうえでプッシュをしたりプッシュするブランチを工夫したりすれば問題が起きないようにできるはできる。&lt;/p&gt;

&lt;p&gt;(※1: と&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873114408/&#34;&gt;O&amp;rsquo;Reillyの蝙蝠本&lt;/a&gt;には書いてあったが、これは&lt;a href=&#34;https://github.com/git/git/blob/master/Documentation/RelNotes/1.7.0.txt&#34;&gt;Git 1.6.xまでの話らしい&lt;/a&gt;。
今はチェックアウトされたブランチにはデフォルトでプッシュできないので、この節に書いた問題は基本的に起きない。
2.6.3で試したら以下のエラーになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require &#39;git reset --hard&#39; to match
remote: error: the work tree to HEAD.
remote: error:
remote: error: You can set &#39;receive.denyCurrentBranch&#39; configuration variable t
remote: error: &#39;ignore&#39; or &#39;warn&#39; in the remote repository to allow pushing int
remote: error: its current branch; however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in som
remote: error: other way.
remote: error:
remote: error: To squelch this message and still keep the default behaviour, se
remote: error: &#39;receive.denyCurrentBranch&#39; configuration variable to &#39;refuse&#39;.
To file://C:/Users/Kaito/Desktop/master
 ! [remote rejected] master -&amp;gt; master (branch is currently checked out)
error: failed to push some refs to &#39;file://C:/Users/Kaito/Desktop/master&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Gitのマージを図解する</title>
          <link>http://tbd.kaitoy.xyz/2015/12/28/git-merge/</link>
          <pubDate>Mon, 28 Dec 2015 01:05:29 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/28/git-merge/</guid>
          <description>

&lt;p&gt;このエントリでは、&lt;a href=&#34;https://git-scm.com/&#34;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/a&gt;が提供するマージのための機能の内、主なもの4つ、&lt;strong&gt;真のマージ&lt;/strong&gt;、&lt;strong&gt;リベース&lt;/strong&gt;、&lt;strong&gt;ファストフォワードマージ&lt;/strong&gt;、&lt;strong&gt;チェリーピック&lt;/strong&gt; について図解する。
ここでマージとは、とあるブランチのコミットが入れた修正を別のブランチに取り込むこととする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/27/git-repository/&#34;&gt;この記事&lt;/a&gt;を事前に呼んでおくとわかりやすいかもしれない。&lt;/p&gt;

&lt;p&gt;ここで説明するマージは全てローカルリポジトリ内のブランチを操作対象とする。&lt;/p&gt;

&lt;h2 id=&#34;真のマージ&#34;&gt;真のマージ&lt;/h2&gt;

&lt;p&gt;真のマージは、複数のブランチでそれぞれ開発が進んでいて、つまりそれぞれのコミットグラフが伸びている場合に、それらの修正を統合するときに実行する。
マージするブランチはいくつでも指定できる。&lt;/p&gt;

&lt;p&gt;基本的なコマンドは&lt;code&gt;git merge &amp;lt;ブランチ(複数可)&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;操作に成功すると、マージ後のプロジェクトの状態を表すコミット(マージコミット)が作られ、カレントブランチの先頭に追加される。
マージコミットは、マージした全てのブランチが指していたコミットを親として持つ。&lt;/p&gt;

&lt;p&gt;このマージはマージコミットを追加するだけであり、既存のコミットを一切変更しないことを認識しておくべし。&lt;/p&gt;

&lt;p&gt;以下、真のマージの実行例を図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_merge/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_merge/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_merge/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_merge/スライド4.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;リベース&#34;&gt;リベース&lt;/h2&gt;

&lt;p&gt;リベースは、あるブランチで作った一連のコミットの起点(ベース)を移動したいときに実行する。
この操作は一般的にはマージとは呼ばれないが、冒頭に書いたマージの定義からするとマージと見なせないこともないのでここに挙げる。&lt;/p&gt;

&lt;p&gt;基本的なコマンドは&lt;code&gt;git rebase &amp;lt;ブランチ&amp;gt;&lt;/code&gt;。
このコマンドは、カレントブランチの起点を指定したブランチが指すコミットに移動する。&lt;/p&gt;

&lt;p&gt;この操作に成功すると、カレントブランチで作ったコミットは(実質)消え、それと同等の修正をもたらす別のコミットが移動先のコミットを起点として作成される。(※1)&lt;/p&gt;

&lt;p&gt;リベースは既存のコミットを消し、コミットグラフを変更してしまうということを認識しておくべし。&lt;/p&gt;

&lt;p&gt;以下、リベースの簡単な実行例を図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_rebase/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_rebase/スライド2.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;上のスライドのように単純なコミットグラフならいいが、リベースするブランチが分岐していたりするとややこしいことが起き得る。
そういうケースには&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873114408/&#34;&gt;O&amp;rsquo;Reillyの蝙蝠本&lt;/a&gt;などでよく勉強してから臨むべし。&lt;/p&gt;

&lt;p&gt;(※1: より正確には&lt;code&gt;git rebase &amp;lt;ブランチ&amp;gt;&lt;/code&gt;は、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;カレントブランチで作った各コミットが入れた変更をパッチにして、&lt;/li&gt;
&lt;li&gt;それを古い順に一つずつ、指定したブランチが指すコミットに適用しながら新しいコミットを作り、&lt;/li&gt;
&lt;li&gt;カレントブランチが指しているコミットを&lt;code&gt;ORIG_HEAD&lt;/code&gt;で指し、&lt;/li&gt;
&lt;li&gt;カレントブランチを最新のコミットを指すよう更新する。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2で、指定したブランチが既にチェリーピック(後述)などでカレントブランチのとあるコミットの変更を取り込んでいた場合、そのコミットのパッチの適用はスキップされ、そのパッチによるコミットも作られない。&lt;/p&gt;

&lt;p&gt;また、上でカレントブランチのコミットは実質消えると書いたが、当面はオブジェクトが本当に消えるわけではないし、&lt;code&gt;ORIG_HEAD&lt;/code&gt;とかが指しているのでもどることもできる。)&lt;/p&gt;

&lt;h2 id=&#34;ファストフォワードマージ&#34;&gt;ファストフォワードマージ&lt;/h2&gt;

&lt;p&gt;ファストフォワードマージは、マージ先のコミットが全てマージ元に含まれているときに使えるマージ。
この操作は既存のコミットグラフをいじらないしマージコミットも作らない特殊なマージ。
(実のところマージじゃないと言ってもいい。)
このマージを実行した後は、コミットグラフは一直線になり、ブランチを作らずにコミットを作った場合と同様になる。&lt;/p&gt;

&lt;p&gt;このマージは、&lt;code&gt;git merge &amp;lt;ブランチ&amp;gt;&lt;/code&gt;を実行したときに可能であれば実行される。
(でなければ真のマージが実行される。オプションで選択することもできる。)&lt;/p&gt;

&lt;p&gt;以下にファストフォワードマージの例を図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_ff/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_ff/スライド2.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ファストフォワードマージはよくリベースとともに実行される。
リベースのスライドの最後のページの図は、ここのスライドの最初のページの図と同じになっている。&lt;/p&gt;

&lt;p&gt;リベース + ファストフォワードは、トピックブランチで入れた修正を、そのブランチを作ったという履歴を残さずに別のブランチに取り入れたいときなどに使う手法。
マージコミットを作る手法よりもコミットグラフをシンプルに保てる。&lt;/p&gt;

&lt;h2 id=&#34;チェリーピック&#34;&gt;チェリーピック&lt;/h2&gt;

&lt;p&gt;チェリーピックは、あるブランチの任意のコミットによる修正を別のブランチに取り込みたいときに実行する。
他の3つのマージに比べて分かりやすい操作であり、また操作対象にするブランチやコミットの自由度が高いので使いやすい。
その反面、コミットログなどに明記しないとどこのコミットをマージしたのかが分からなくなる。&lt;/p&gt;

&lt;p&gt;基本的なコマンドは&lt;code&gt;git cherry-pick &amp;lt;コミット&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;操作に成功すると、指定したコミットと同等の修正をもたらす新しいコミットが作成され、&lt;code&gt;HEAD&lt;/code&gt;に追加される。&lt;/p&gt;

&lt;p&gt;この操作はコミットを追加するだけであり、既存のコミットは変更しない。&lt;/p&gt;

&lt;p&gt;以下にチェリーピックの例を図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_cherry-pick/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-merge/git_cherry-pick/スライド2.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Gitのリポジトリの中身をなるべく正確に理解する</title>
          <link>http://tbd.kaitoy.xyz/2015/12/27/git-repository/</link>
          <pubDate>Sun, 27 Dec 2015 11:34:18 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/27/git-repository/</guid>
          <description>

&lt;p&gt;このエントリでは、&lt;a href=&#34;https://git-scm.com/&#34;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/a&gt;の基本的な使い方は理解している前提で、そのリポジトリの構造をなるべく正確に説明する。&lt;/p&gt;

&lt;p&gt;リポジトリ構造の理解を深めることで、Gitにおけるブランチの概念などの理解が深まったり、&lt;a href=&#34;http://tbd.kaitoy.xyz/2016/01/01/git-revert-reset/#git-reset&#34;&gt;&lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;などのGit特有で分かり辛いコマンドを自信をもって使えるようになったり、なにより、Gitを使う上での最大のハードルである &lt;strong&gt;インデックス&lt;/strong&gt; や &lt;strong&gt;HEAD&lt;/strong&gt; の概念を完璧に理解できるというメリットがある。&lt;/p&gt;

&lt;p&gt;なお、ここに書いてあることは概ね、筆者が&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873114408/&#34;&gt;O&amp;rsquo;Reillyの蝙蝠本&lt;/a&gt;を読んで得た知識に基づく。&lt;/p&gt;

&lt;h1 id=&#34;gitリポジトリの中身&#34;&gt;Gitリポジトリの中身&lt;/h1&gt;

&lt;p&gt;Gitのリポジトリは、プロジェクトをクローンしたときとかにできる&lt;code&gt;.git&lt;/code&gt;ディレクトリ内に詰まっている。
このディレクトリには、&lt;strong&gt;オブジェクト格納領域&lt;/strong&gt; と &lt;strong&gt;インデックス&lt;/strong&gt; というデータ構造が入っている。
また、&lt;strong&gt;参照 (ref)&lt;/strong&gt; や &lt;strong&gt;シンボリック参照 (symref)&lt;/strong&gt; というものも入っている。&lt;/p&gt;

&lt;p&gt;以下、それぞれについて説明する。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト格納領域&#34;&gt;オブジェクト格納領域&lt;/h3&gt;

&lt;p&gt;オブジェクト格納領域は、ファイルシステム上では&lt;code&gt;.git/objects/&lt;/code&gt;以下にあたる。&lt;/p&gt;

&lt;p&gt;ここには、バージョン管理されているファイルの情報やそのコミット履歴などが保存されていて、具体的には以下の4種類のオブジェクトが置かれている。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ブロブ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一つのファイルを表すオブジェクト。
バージョン管理対象のファイルの内容(だけ)を保持する。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;ツリー&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一つのディレクトリを表すオブジェクト。ブロブや別のツリーを指すポインタを持ち、またそれらが表すファイル/ディレクトリの名前や属性を保持する。
つまり、これとブロブを組み合わせると、ファイルシステム上のディレクトリツリーを表すことができる。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;コミット&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一つのコミットを表すオブジェクト。コミット日時やログメッセージなどの情報と、一つ前のコミット(親コミット)を指すポインタと、一つのツリーを指すポインタを持つ。
このツリーはプロジェクトのルートディレクトリを表す。
つまり、一つのコミットは、プロジェクトのある時点でのディレクトリツリー全体を表してもいる。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;タグ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一つの注釈付きタグ(&lt;code&gt;git tag -a&lt;/code&gt;で作るタグ)を表すオブジェクト。
タグ名やタグにつけたコメントなどの情報と、一つのオブジェクト(普通はコミット)へのポインタを持つ。
因みに軽量タグ(&lt;code&gt;git tag&lt;/code&gt;で作るタグ)はオブジェクトにならない。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ファイルシステム上で、一つのオブジェクトは一つのファイルに書き込まれ、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Zlib&#34;&gt;zlib&lt;/a&gt;で圧縮され、&lt;code&gt;.git/objects/&lt;/code&gt;以下に配置される。
そのファイルへのパスには、オブジェクトのコンテンツから計算されたSHA1ハッシュの値(i.e. オブジェクトの名前)が使われる。
例えば&lt;code&gt;.git/objects/16/cacde1ddabe1698b0e41e091e4697313e2b7e5&lt;/code&gt;というファイルがあったら、これは &lt;strong&gt;16cacde1ddabe1698b0e41e091e4697313e2b7e5&lt;/strong&gt; という名のオブジェクトの実体。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git cat-file -p &amp;lt;SHA1ハッシュ&amp;gt;&lt;/code&gt;でオブジェクトのコンテンツを見れるので、いくつか見てみると面白い。&lt;/p&gt;

&lt;h3 id=&#34;インデックス&#34;&gt;インデックス&lt;/h3&gt;

&lt;p&gt;インデックスは、&lt;code&gt;git add&lt;/code&gt;の説明とかに出てくる「インデックス」とか「ステージング」とか呼ばれる機能を実現するためのデータ構造で、ファイルシステム上では&lt;code&gt;.git/index&lt;/code&gt;というバイナリファイルにあたる。&lt;/p&gt;

&lt;p&gt;インデックスは、プロジェクトのある時点でのディレクトリツリー全体を表すデータをもつ。
具体的には、プロジェクトの各ファイルについて、対応するブロブへのポインタと、プロジェクトルートディレクトリからの相対パスが記録されている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git ls-files --stage&lt;/code&gt;で&lt;code&gt;.git/index&lt;/code&gt;の内容を見れる。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト格納領域とインデックスの図解&#34;&gt;オブジェクト格納領域とインデックスの図解&lt;/h3&gt;

&lt;p&gt;ワーキングディレクトリに変更を入れ、&lt;code&gt;git add&lt;/code&gt;、&lt;code&gt;git commit&lt;/code&gt;をする中で、オブジェクト格納領域とインデックスがどう変化するかを図にした。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド4.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド5.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド6.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_repo/スライド7.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(タグオブジェクトについては次の節で。)&lt;/p&gt;

&lt;p&gt;スライドの1ページ目や最後のページのようにワーキングディレクトリとインデックスとオブジェクト格納領域が同期していて、&lt;code&gt;git status&lt;/code&gt;を実行すると&lt;code&gt;nothing to commit, working directory clean&lt;/code&gt;と表示される状態をワーキングディレクトリがクリーンであると言い、そうでない状態をワーキングディレクトリがダーティであると言う。&lt;/p&gt;

&lt;p&gt;このスライドにより、Gitがファイルの履歴をどう記録しているかがよく分かるはず。
特に、ブロブが常にファイルのある時点の内容全体を保持していて、Gitが(&lt;a href=&#34;https://subversion.apache.org/&#34;&gt;Subversion&lt;/a&gt;のように)差分を保存しているわけではないことは覚えておくべし。&lt;/p&gt;

&lt;p&gt;スライドの最後のページのオブジェクト格納領域の図で、ツリーとブロブとそれらを指す矢印を省略すると、Gitのブランチ等の説明でよく見かける丸が矢印で連なった図(コミットグラフ)になる。以降の説明でそのような図を使うが、丸がコミットを意味していて、各コミットがルートツリーを指していることはよく認識しておくべし。&lt;/p&gt;

&lt;h3 id=&#34;参照-ref&#34;&gt;参照 (ref)&lt;/h3&gt;

&lt;p&gt;参照は、一つのオブジェクトを指し示すポインタのようなもので、普通はコミットオブジェクトを指す。
参照には、&lt;strong&gt;ローカルブランチ&lt;/strong&gt;、&lt;strong&gt;リモート追跡ブランチ&lt;/strong&gt;、&lt;strong&gt;タグ&lt;/strong&gt; の三種類がある。&lt;/p&gt;

&lt;p&gt;ファイルシステム上では&lt;code&gt;.git/refs/&lt;/code&gt;以下にある、指し示すオブジェクトのSHA1ハッシュ値が書かれただけのテキストファイルにあたる。
&lt;code&gt;.git/refs/heads/&lt;/code&gt;以下にローカルブランチ、&lt;code&gt;.git/refs/remotes/&lt;/code&gt;以下にリモート追跡ブランチ、&lt;code&gt;.git/refs/tags/&lt;/code&gt;以下にタグが置かれる。&lt;/p&gt;

&lt;p&gt;参照は、Gitコマンドなどにおいてコミットを指定する方法としてSHA1ハッシュ値の代わりに使える。
この時、参照の名前は上記ファイルシステム上のパスから&lt;code&gt;.git/&lt;/code&gt;を省いたものになる。
例えば&lt;code&gt;refs/heads/master&lt;/code&gt;。さらに、ディレクトリは省略できるので、同じ参照は&lt;code&gt;heads/master&lt;/code&gt;や単に&lt;code&gt;master&lt;/code&gt;とも書ける。&lt;/p&gt;

&lt;p&gt;ここで、ブランチやタグが単なる参照であるところに注目。
Subversionのようにリポジトリのコピーを作るのとはかなり異なる。
Gitのブランチを作るというのは単に参照を追加するだけだし、ブランチをチェックアウトするというのはブランチが指すコミットが指すツリーが表すディレクトリツリーをファイルシステムに展開するということ。
この実装によってGitのブランチが軽量で速いものになっている。&lt;/p&gt;

&lt;p&gt;ローカルブランチの挙動を以下に図示する。図中で、各コミットには便宜上ラベルとしてアルファベットを付けている。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_branch/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_branch/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_branch/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_branch/スライド4.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_branch/スライド5.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このスライドの最後のページでmasterブランチが本流でbugfixブランチが支流かのように書いているが、実際は実装上それらに差はなく全く対等である。&lt;/p&gt;

&lt;p&gt;また、ブランチは単なる一方的な参照であり、コミットオブジェクトからはそれに全く関与しないことに注意。
ブランチを削除してもそれによってコミットが消えることはない(※1)し、また例えば、スライドの最後のページでbugfixブランチを削除したらXがどのブランチで作られたコミットなのかを知るすべはなくなる。&lt;/p&gt;

&lt;p&gt;(※1: ブランチを削除することにより到達不能になるコミットは、結果的に&lt;a href=&#34;https://git-scm.com/book/ja/v2/Git%E3%81%AE%E5%86%85%E5%81%B4-%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E3%83%AA%E3%82%AB%E3%83%90%E3%83%AA&#34;&gt;&lt;code&gt;git gc&lt;/code&gt;&lt;/a&gt;により削除されはする。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;次に、タグの挙動を以下に図示する。&lt;/p&gt;

&lt;ul class=&#34;bxslider&#34;&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_tag/スライド1.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_tag/スライド2.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_tag/スライド3.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_tag/スライド4.PNG&#34; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/git-repository/git_tag/スライド5.PNG&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;図中で、タグオブジェクトはオブジェクトなのでオブジェクト格納領域に入り、それを指す参照のタグは&lt;code&gt;.git/refs/&lt;/code&gt;に入る。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;リモート追跡ブランチについては&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/31/git-dvc/&#34;&gt;別のエントリ&lt;/a&gt;で書く。&lt;/p&gt;

&lt;h3 id=&#34;シンボリック参照-symref&#34;&gt;シンボリック参照 (symref)&lt;/h3&gt;

&lt;p&gt;シンボリック参照は参照やオブジェクトを指し示すポインタのようなもので、以下の四つがある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;カレントブランチ、つまりチェックアウトしているブランチ(i.e. 参照)を指す。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;ORIG_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;や&lt;a href=&#34;http://tbd.kaitoy.xyz/2016/01/01/git-revert-reset/#git-reset&#34;&gt;&lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;でHEADが更新されたとき、更新前のHEADが指していたブランチが指していたコミットを指す。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;FETCH_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最後にフェッチされたブランチの最新コミットを指す。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;MERGE_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;マージ操作中に作られ、HEADにマージされようとしているコミットを指す。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;それぞれが、Gitコマンドなどにおいてコミットを指定する方法としてSHA1ハッシュ値の代わりに使える。&lt;/p&gt;

&lt;p&gt;ファイルシステム上では&lt;code&gt;.git/{HEAD,ORIG_HEAD,FETCH_HEAD,MERGE_HEAD}&lt;/code&gt;にあたり、全て単純なテキストファイルである。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上がGitリポジトリの中身のほぼ全容。あとは設定ファイルとかフックスクリプトとかがあるだけ。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
